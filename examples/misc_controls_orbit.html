<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - orbit controls</title>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
		/>
		<link type="text/css" rel="stylesheet" href="main.css" />
		<style>
			body {
				background-color: #ccc;
				color: #000;
			}

			a {
				color: #f00;
			}
		</style>
	</head>

	<body>
		<div id="info">
			<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> -
			orbit controls
		</div>

		<script type="module">
			import * as THREE from "../build/three.module.js";
			import {  Cube } from '../Figuras/Cube.js';
			import { ShadowMesh } from "./jsm/objects/ShadowMesh.js";
			import { OrbitControls } from "./jsm/controls/OrbitControls.js";
			var sunLight = new THREE.DirectionalLight("rgb(255,255,255)", 1);

			var arrowHelper1, arrowHelper2, arrowHelper3;
			var arrowDirection = new THREE.Vector3();
			var arrowPosition1 = new THREE.Vector3();
			var arrowPosition2 = new THREE.Vector3();
			var arrowPosition3 = new THREE.Vector3();
			var useDirectionalLight = true;
			var cubeshadow,cubeshadow2;
			var camera, controls, scene, renderer;
			var groundMesh;
			var cube;
			var planeConstant = 0.01; // this value must be slightly higher than the groundMesh's y position of 0.0
			var normalVector = new THREE.Vector3(0, 1, 0);
			var groundPlane = new THREE.Plane(normalVector, planeConstant);
			var lightPosition4D = new THREE.Vector4();
			init();
			//render(); // remove when using next line for animation loop (requestAnimationFrame)
			animate();

			function init() {
				scene = new THREE.Scene();
				scene.background = new THREE.Color("#22264f");
				// scene.fog = new THREE.FogExp2(0xcccccc, 0.002);

				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				document.body.appendChild(renderer.domElement);

				camera = new THREE.PerspectiveCamera(
					60,
					window.innerWidth / window.innerHeight,
					1,
					1000
				);
				camera.position.set(200,100, 0);

				// controls

				controls = new OrbitControls(camera, renderer.domElement);

				//controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

				controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
				controls.dampingFactor = 0.05;

				controls.screenSpacePanning = false;

				controls.minDistance = 2;
				controls.maxDistance = 3000;

				controls.maxPolarAngle = Math.PI * 2;

				sunLight.position.set(400, 200, -1);
				sunLight.lookAt(scene.position);
				scene.add(sunLight);

				lightPosition4D.x = sunLight.position.x;
				lightPosition4D.y = sunLight.position.y;
				lightPosition4D.z = sunLight.position.z;
				// amount of light-ray divergence. Ranging from:
				// 0.001 = sunlight(min divergence) to 1.0 = pointlight(max divergence)
				lightPosition4D.w = 0.001;

				arrowDirection
					.subVectors(scene.position, sunLight.position)
					.normalize();
				arrowPosition1.copy(sunLight.position);
				arrowHelper1 = new THREE.ArrowHelper(
					arrowDirection,
					arrowPosition1,
					10,
					0xffff00,
					10,
					10
				);
				scene.add(arrowHelper1);
				arrowPosition2
					.copy(sunLight.position)
					.add(new THREE.Vector3(0, 0.2, 0));
				arrowHelper2 = new THREE.ArrowHelper(
					arrowDirection,
					arrowPosition2,
					0.9,
					0xffff00,
					0.25,
					0.08
				);
				scene.add(arrowHelper2);
				arrowPosition3
					.copy(sunLight.position)
					.add(new THREE.Vector3(0, -0.2, 0));
				arrowHelper3 = new THREE.ArrowHelper(
					arrowDirection,
					arrowPosition3,
					0.9,
					0xffff00,
					0.25,
					0.08
				);
				scene.add(arrowHelper3);

				arrowHelper1.visible = true;
				arrowHelper2.visible = true;
				arrowHelper3.visible = true;
				
				var groundGeometry = new THREE.BoxBufferGeometry(1000, 0.01, 1000);
				var groundMaterial = new THREE.MeshLambertMaterial({
					color: "rgb(255,255,255)"
				});
				groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
				groundMesh.position.y = 0.0; //this value must be slightly lower than the planeConstant (0.01) parameter above
				scene.add(groundMesh);

				// world

				var geometry = new THREE.BoxBufferGeometry( 50, 70, 59 );
				var material =  new THREE.MeshLambertMaterial( { color: 'rgb(255,0,0)', emissive: 0x200000 } );
				cube = new THREE.Mesh(geometry, material);
				scene.add(cube);
				cube.position.x = 0;
				cube.position.y = 35;
				cube.position.z = 0;
				


				let cubega = new Cube(20,20,20,'#33ffaa');
				cubega.setPosition(100,100,0);
				scene.add(cubega.getModel());
				// cubeshadow = new ShadowMesh(cube);
				// scene.add(cubeshadow);



				window.addEventListener("resize", onWindowResize, false);
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function animate() {
				requestAnimationFrame(animate);

				controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
				// cube.rotation.x += 0.01;
				// cube.rotation.y += 0.01;

				//cubeshadow.update(groundPlane, lightPosition4D);
				render();
			}

			function render() {
				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>
